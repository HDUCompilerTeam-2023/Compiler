# Change log

## 0.25.0

- 对各个功能模块做了划分
  - frontend 模块实现前端分析，读入源代码进行语法分析于语义分析；
    - 依赖于 hir_gen 模块与 frontend_grammar 模块
  - frontend_grammar 模块使用 bison 和 fleax 实现了解析功能；
    - 依赖于 frontend_syntax 模块
  - frontend_syntax 模块定义了语法分析过程中的语义处理函数；
    - 依赖于 hir_gen 模块
  - frontend_log 模块提供了前端部分的调试输出功能；
    - 依赖于 log 模块
  - hir_gen 模块定义了 hir 的数据结构与生成析构的函数；
    - 依赖于 hir 模块
  - hir 模块定义了高级中间语言 hir 的数据接口；
- hir 高级中间语言定义
  - hir 由 ast、type 和 symbol_table 组成
  - symbol_table 使用一张哈希表实现访问

## 0.24.0

略过没记录的修改

## 0.23.1

词法分析时，使用函数 atoi 获得整型常量的值时，只能解析十进制常量

现使用 strtol 函数，可解析所有格式

## 0.23.0

根据语法分析树，打印源程序

## 0.22.0

返回语法分析树的根节点

## 0.21.0

词法分析时检测到错误不再退出，跳过错误部分继续检测。

## 0.20.0、

更清晰的前端输出

## 0.19.0

可重入的词法分析器与语法分析器

## 0.18.0

创建语法分析树

## 0.17.0

更详细的错误信息输出

## 0.16.0

词法分析时产生 ID 和 INTCONST 的节点

## 0.15.0

添加语法分析树节点的数据结构

## 0.14.0

给 0.12.0 与 0.13.0 新增的规则增加输出

## 0.13.0

为更规范地定义指针等复杂的变量，参考 C 标准，重新设计了定义语句，将函数的定义也囊括其中

针对这部分语义分析时需要判断如下内容

- 类型是否合法 （ `int short` `short int` 等序列合法，`int int` 等序列不合法 ）
- 修饰符是否重复 （ 目前仅支持 `const` 修饰符 ）
- 函数不能返回函数或数组，数组的元素不能是函数 （ 函数可以返回数组或函数的指针，数组的元素可以是函数指针 ）
- 函数定义不能用 `=` 进行初始化
- 未指定的下标定义是否能从初始化的值中确定

## 0.12.0

新增自增自减运算符，为了表示前缀与后缀的自增自减运算符的优先级，新增后缀表达式，将函数调用运算符与下标运算符归入后缀表达式

为了使用更复杂的左值，删除左值规则，使用一元表达式来代替，左值的判定将在语义分析阶段完成

经过实验，下标运算时，可以使用逗号表达式

## 0.11.0

函数实参不使用逗号表达式
目前不使用逗号表达式的部分

- 下标
- 变量初始化的值
- 函数实参

## 0.10.0

支持使用整型后缀，形如`u`、`l`、`ul`、`ull`等

## 0.9.0

完成所有文法规则规约时的输出

## 0.8.0

不使用 bison 的优先级消除 if-else 规则的二义性，新方案将 while 后的语句作了分类
基于语句的 if-else 是否配对，while 后跟配对的语句可推出配对的语句，后跟不能配对的语句则推出不配对的语句

其他特性

- 在不可使用逗号表达式的规则中使用赋值表达式
- 目前暂定不可使用逗号表达式的部分
  - 下标定义
  - 变量初始化的值
- 函数形参的下标的第一项的值可选为空或给出，例如，`int f(int a[][2])`与`int f(int a[2][2])`都是正确的

## 0.7.0

基本实现语法分析

## 0.6.0

词法分析时识别并跳过注释

## 0.5.0

输出语法分析过程的调试信息

## 0.4.0

输出词法分析过程的调试信息

## 0.3.0

新增 log.h 使用宏 `yydebug(fmt, ...)` 输出调试信息

## 0.2.0

部分实现语法分析，可识别若干条常量定义语句

## 0.1.1

修正词法分析过程对规则 "return" 的 `TOKEN` 错误

## 0.1.0

实现 SysY 语言的词法分析，识别并输出

## 0.0.0

实现一个识别关系运算符的词法分析器
